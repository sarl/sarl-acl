/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2017 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.acl.protocol.request

import io.sarl.acl.message.ACLMessage
import io.sarl.acl.message.Performative
import io.sarl.acl.protocol.EnumFipaProtocol
import io.sarl.acl.protocol.FipaProtocol
import io.sarl.acl.protocol.ProtocolResult
import io.sarl.acl.protocol.ProtocolState
import io.sarl.core.Logging

/** 
 * Request Interaction protocol.
 * 
 * @see <a href="http://www.fipa.org/specs/fipa00026/SC00026H.html">FIPA Request Interaction Protocol Specification</a>
 * 
 * @author $Author: sgalland$
 * @author $Author: ngaud$
 * @version $FullVersion$
 * @mavengroupid $Groupid$
 * @mavenartifactid $ArtifactId$
 */
behavior FipaRequestProtocol extends FipaProtocol {

	uses Logging

	protected def initialize {
		this.maximumParticipants = 2
	}

	def getProtocolType : EnumFipaProtocol {
		EnumFipaProtocol::FIPA_REQUEST
	}

	protected def getErrorState : ProtocolState {
		RequestProtocolState::BROKEN_PROTOCOL
	}






	/** 
	 * Send a request to the participant.
	 * This method must be called by the initiator.
	 * 
	 * @param content
	 */
	public def request(content : Object) {
		if (isInitiator && (state == RequestProtocolState::NOT_STARTED)) {
			sendMessage(content, Performative::REQUEST, participants.get(0))
			state = RequestProtocolState::WAITING_ANSWER
		}
		else if(isParticipant){
			error(Messages::FipaRequestProtocol_0)
		}
		else{
			error(Messages::FipaRequestProtocol_1)
		}
	}

	var requestResult : ProtocolResult

	on ACLMessage [
		isParticipant
		&& state == RequestProtocolState::NOT_STARTED
		&& hasInitial(Performative.REQUEST)
	] {
		initiate(occurrence.sender, ID)
		conversationID = occurrence.conversationID
		state = RequestProtocolState::WAITING_REQUEST
		resetStartedTime
		this.requestResult = new ProtocolResult(occurrence.sender, Performative::REQUEST, occurrence.content.content.toString)
	}

	/** 
	 * Looks if there is a pending request in the mailbox
	 * 
	 * @return ProtocolResult the result
	 */
	public def getRequest : ProtocolResult {
		
		if( hasReachedTimeout ){
			addError(Messages::FipaRequestProtocol_2)
		}
		else{
			if (isParticipant && (state == RequestProtocolState::NOT_STARTED)) {
				
				/* TODO var message = getRefAclAgent().getACLMessage(EnumFipaProtocol.FIPA_REQUEST, Performative.REQUEST);
				
				if (message != null) {
					initiate(message.getSender(), getRefAclAgent().getAddress());
					
					setConversationId(message.getConversationId());
					setState(RequestProtocolState::WAITING_REQUEST);
					
					resetStartedTime();
					
					return new ProtocolResult(message.getSender(), Performative.REQUEST, message.getContent().getContent().toString());
				}*/
			}
			else if (isInitiator) {
				addError(Messages::FipaRequestProtocol_3)
			}
			else {
				addError(Messages::FipaRequestProtocol_4)
			}
		}
		return null
	}
	
	/**
	 * Refuses the request made by the initiator.
	 * This method must be called by the participant.
	 * 
	 * @param content
	 * 
	 * @see #agree(Object)
	 */
	public def refuse(content : Object) {

		if (isParticipant && (state == RequestProtocolState::WAITING_REQUEST)) {
			sendMessage(content, Performative.REFUSE, getInitiator)
			setFinalStep
		}
		else if (isInitiator) {
			addError(Messages::FipaRequestProtocol_5)
		}
		else{
			addError(Messages::FipaRequestProtocol_6)
		}
	}
	
	/**
	 * Accepts the request made by the initiator.
	 * This method must be called by the participant.
	 * 
	 * Once the request has been agreed upon, 
	 * then the Participant must send one of the following notifications:
	 * failure(), informDone(), informResult().
	 * 
	 * @param content
	 * 
	 * @see #refuse(Object)
	 * @see #failure(Object)
	 * @see #informDone(Object)
	 * @see #informResult(Object)
	 */
	public def agree(content : Object) {

		if( isParticipant && (state == RequestProtocolState::WAITING_REQUEST)){
			sendMessage(content, Performative.AGREE, getInitiator)
			state = RequestProtocolState::SENDING_RESULT
		}
		else if (isInitiator) {
			addError(Messages::FipaRequestProtocol_7)
		}
		else{
			addError(Messages::FipaRequestProtocol_8)
		}
	}
	
	/**
	 * Replies the answer of the participant to the request. (AGREE or REFUSE)
	 * 
	 * If the request has been agreed upon, 
	 * then the Participant will send one of the following notifications:
	 * failure(), informDone(), informResult().
	 * 
	 * This notification can be obtained by the initiator thanks to getNotification().
	 * 
	 * @return the answer (Performative + Content) or null if no answer.
	 * 
	 * @see #refuse(Object)
	 * @see #agree(Object)
	 */
	public def getAnswer : ProtocolResult {
		
		if (hasReachedTimeout){
			addError(Messages::FipaRequestProtocol_9)
		}
		else{
			if (isInitiator && (state == RequestProtocolState::WAITING_ANSWER)) {
				/* TODO
				var result : ProtocolResult
				var aMsg  = getRefAclAgent().getACLMessageForConversationId( getConversationId() );
				
				if( aMsg != null )
				{
					result = new ProtocolResult();
					result.setPerformative( aMsg.getPerformative() );
					result.setContent( aMsg.getContent().getContent() );
					
					if( result.getPerformative().compareTo(Performative.NOT_UNDERSTOOD) == 0 )
						setFinalStep();
					else if( result.getPerformative().compareTo(Performative.REFUSE) == 0 )
						setFinalStep();
					else if( result.getPerformative().compareTo(Performative.AGREE) == 0 )
						setState(RequestProtocolState::WAITING_RESULT);
					
					resetStartedTime();
				}
				
				return result;*/
			}
			else if(isParticipant) {
				addError(Messages::FipaRequestProtocol_10)
			}
			else{
				addError(Messages::FipaRequestProtocol_11)
			}
		}
		return null
	}
	
	/**
	 * Once the request has been agreed upon, 
	 * then the Participant can communicate a failure 
	 * if it fails in its attempt to fill the request
	 * 
	 * @param content
	 */
	public def failure(content : Object) {
		if (isParticipant && (state == RequestProtocolState::SENDING_RESULT)) {
			sendMessage(content, Performative.FAILURE, getInitiator())
			setFinalStep
		}
		else if( isInitiator ){
			addError(Messages::FipaRequestProtocol_12)
		}
		else{
			addError(Messages::FipaRequestProtocol_13)
		}
	}
	
	/**
	 * Once the request has been agreed upon, 
	 * then the Participant can communicate an inform-done 
	 * if it successfully completes the request and only wishes to indicate that it is done.
	 * 
	 * @param content
	 */
	public def informDone(content : Object) {
		if( isParticipant && ( state == RequestProtocolState::SENDING_RESULT ) ){
			sendMessage(content, Performative.INFORM, getInitiator)
			setFinalStep
		}
		else if( isInitiator ){
			addError(Messages::FipaRequestProtocol_14)
		}
		else{
			addError(Messages::FipaRequestProtocol_15)
		}
	}
	
	/**
	 * Once the request has been agreed upon, 
	 * then the Participant can communicate an inform-result 
	 * if it wishes to indicate both that it is done and notify the initiator of the results.
	 * 
	 * @param content
	 */
	public def informResult(content : Object) {

		if( isParticipant && ( state == RequestProtocolState::SENDING_RESULT ) ){
			sendMessage(content, Performative.INFORM, getInitiator)
			setFinalStep
		}
		else if( isInitiator ){
			addError(Messages::FipaRequestProtocol_16)
		}
		else{
			addError(Messages::FipaRequestProtocol_17)
		}
	}
	
	/**
	 * 
	 * @return the notification (Performative + Content)
	 * 
	 * @see #failure(Object)
	 * @see #informDone(Object)
	 * @see #informResult(Object)
	 */
	public def getResult : ProtocolResult {

		if( hasReachedTimeout ){
			addError(Messages::FipaRequestProtocol_18)
		}
		else{
			if (isInitiator && (state == RequestProtocolState::WAITING_RESULT) || state == RequestProtocolState::CANCELING) {
				/* TODO 
				ProtocolResult result = null;
				ACLMessage aMsg = getRefAclAgent().getACLMessageForConversationId( getConversationId() );
				
				if( aMsg != null)
				{
					result = new ProtocolResult();
					result.setPerformative( aMsg.getPerformative() );
					result.setContent( aMsg.getContent().getContent() );
					
					setFinalStep();
					
					resetStartedTime();
				}
				
				return result;*/
			}
			else if(isParticipant){
				addError(Messages::FipaRequestProtocol_19)
			}
			else{
				addError(Messages::FipaRequestProtocol_20)
			}
		}
		
		return null
	}
		
}
