/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2017 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.acl.encoding

import java.util.TimeZone
import java.util.Calendar
import java.util.Date

/** Provides utilities to convert dates for ACL.
 * 
 * @author $Author: sgalland$
 * @author $Author: ngaud$
 * @version $FullVersion$
 * @mavengroupid $Groupid$
 * @mavenartifactid $ArtifactId$
 */
public class ACLDateUtil {

	static val YEAR = 365*24*60*60*1000L
    static val MONTH = 30*24*60*60*1000L
    static val DAY = 24*60*60*1000
    static val HOUR = 60*60*1000
    static val MINUTE = 60*1000
    static val SEC = 1000
    
    /**
     * Replies the token that is representing a time in ACL format of
     * the specified date.
     * 
     * @param date
     * @return the ACL time token from <var>date</var>.
     */
	static def toDateTimeToken(date : Date) : String {
		if (date === null) {
			return null
		}
		
		var utcCal = Calendar::getInstance(TimeZone::getTimeZone("GMT")); //$NON-NLS-1$
		utcCal.time = date
        var formatedDate = new StringBuilder

        formatedDate.append(zeroPaddingNumber(utcCal.get(Calendar::YEAR), 4))
        formatedDate.append(zeroPaddingNumber(utcCal.get(Calendar::MONTH) + 1, 2))
        formatedDate.append(zeroPaddingNumber(utcCal.get(Calendar::DATE), 2))
        formatedDate.append("T")
        formatedDate.append(zeroPaddingNumber(utcCal.get(Calendar::HOUR_OF_DAY), 2))
        formatedDate.append(zeroPaddingNumber(utcCal.get(Calendar::MINUTE), 2))
        formatedDate.append(zeroPaddingNumber(utcCal.get(Calendar::SECOND), 2))
        formatedDate.append(zeroPaddingNumber(utcCal.get(Calendar::MILLISECOND), 3))
        formatedDate.append("Z")
        
        return formatedDate.toString
	}
	
	/**
	 * Parse an ACL time token to produce a Java date.
	 * 
	 * @param dateTimeToken is the ACL time to parse.
	 * @return the Java representation of <var>dataTimeToken</var>
	 */
	static def toDate(dateTimeToken : String) : Date {
		if (dateTimeToken.isNullOrEmpty) {
			return null
		}
		
		var sign = dateTimeToken.charAt(0)
		
		if ((sign == '+') || (sign == '-')) {
			// convert a relative time into an absolute time
			var millisec = Long::parseLong(dateTimeToken.substring(1, 5)) * YEAR +
				Long::parseLong(dateTimeToken.substring(5, 7)) * MONTH +
				Long::parseLong(dateTimeToken.substring(7, 9)) * DAY +
				Long::parseLong(dateTimeToken.substring(10, 12)) * HOUR +
				Long::parseLong(dateTimeToken.substring(12, 14)) * MINUTE +
				Long::parseLong(dateTimeToken.substring(14, 16)) * SEC
		
			millisec = System::currentTimeMillis() + if (sign == '+') millisec else -millisec
			return new Date(millisec)
		}
		if (dateTimeToken.endsWith("Z")) { //$NON-NLS-1$
		    // Preferred format is to pass UTC times, indicated by trailing 'Z'
		    return computeCalendar(dateTimeToken, true).time
		}
		// Alternate format is to use local times - no trailing 'Z'
		return computeCalendar(dateTimeToken, false).time
	}
	
	
	private static def computeCalendar(dateTimeToken : String, utc : boolean) : Calendar {
		var cal : Calendar
		
		if (utc) {
			cal = Calendar::getInstance(TimeZone::getTimeZone("GMT"))
		} else {
			cal = Calendar::getInstance
		}
		
		cal.set(Calendar::YEAR, Integer::parseInt(dateTimeToken.substring(0, 4)))
		cal.set(Calendar::MONTH, Integer::parseInt(dateTimeToken.substring(4, 6)) - 1)
		cal.set(Calendar::DATE, Integer::parseInt(dateTimeToken.substring(6, 8)))
		cal.set(Calendar::HOUR_OF_DAY, Integer::parseInt(dateTimeToken.substring(9, 11)))
		cal.set(Calendar::MINUTE, Integer::parseInt(dateTimeToken.substring(11, 13))) 
		cal.set(Calendar::SECOND, Integer::parseInt(dateTimeToken.substring(13, 15)))
		cal.set(Calendar::MILLISECOND, Integer::parseInt(dateTimeToken.substring(15, 18)))
		
		return cal
	}
	
	private static def zeroPaddingNumber(value : long, digits : int) : String {
		var s = new StringBuilder(Long::toString(value))
		var n = digits - s.length
		
		for (i : 0..<n) {
			s.insert(0, "0")
		}
		
		return s.toString
	}

	/** Replies if the given string-representation of a date
	 * contains the designator of a type.
	 * <p>
	 * The type designator is an alphabetic character (ie. a
	 * letter) at the end of the string.
	 * 
	 * @param s is the string-representation to parse
	 * @return <code>true</code> if a type designator is inside;
	 * <code>false</code> otherwise.
	 */
	public static def containsTypeDesignator(s : String) : boolean {
        var a = s.charAt(s.length()-1)
        return ((a >= 'a' && a <= 'z') || (a >= 'A' && a <= 'Z'))
    }
   
}
