/*
 * $Id$
 *
 * SARL is an general-purpose agent programming language.
 * More details on http://www.sarl.io
 *
 * Copyright (C) 2014-2017 the original authors or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.sarl.acl.encoding

import io.sarl.acl.encoding.bitefficient.BitEfficientEnvelopeCodec
import io.sarl.acl.message.ACLMessage
import io.sarl.acl.message.ACLMessageContent
import io.sarl.acl.message.ACLMessageEnvelope
import java.nio.ByteBuffer
import java.lang.reflect.Array
import io.sarl.core.Logging
import io.sarl.acl.message.ACLRepresentation
import io.sarl.acl.encoding.bitefficient.BitEfficientACLCodec
import io.sarl.acl.encoding.string.StringACLCodec
import io.sarl.acl.encoding.xml.XMLACLCodec
import io.sarl.acl.encoding.json.JSONACLCodec
import io.sarl.acl.encoding.xml.XMLEnvelopeCodec
import io.sarl.acl.message.ACLTransportMessage

/** 
 * This class manages all the encoding/decoding repartition tasks.
 * 
 * @author $Author: sgalland$
 * @author $Author: ngaud$
 * @version $FullVersion$
 * @mavengroupid $Groupid$
 * @mavenartifactid $ArtifactId$
 */
skill DefaultACLEncoding implements ACLEncoding {

	uses Logging

	protected static final class Constants {
		/** 
		 * The normal size of the envelope length
		 */
		public static var ENVELOPE_LENGTH = 2
		
		/**
		 * The big size of the envelope length
		 */
		public static var BIG_ENVELOPE_LENGTH = 6

		private new { }
	}

	/**
	 * the ACLMessageContentEncodingService used to encode the ACLMessageContent
	 */
	var contentEncodingService : ACLMessageContentEncodingService
	
	/**
	 * the ACLMessageEnvelopeEncodingService used to encode the ACLMessageEnvelope
	 */
	var envelopeEncodingService : ACLMessageEnvelopeEncodingService

	def encode(aMsg : ACLMessage, parameters : Object*) : byte[] {
		aMsg.envelope.initEncodingServices
    	return buildEncodedACLMessage(
    		this.contentEncodingService.encode(aMsg),
    		this.envelopeEncodingService.encode(aMsg.getEnvelope()));
    }

	/** 
	 * Gets the payload 
	 * for a given content encoded in an array of bytes 
	 * and for a given envelope encoded in an array of bytes.
	 * <p>
	 * To be able to easily get back the envelope and the content 
	 * from the payload when decoding, the payload must respect 
	 * the following representation as defined by Fipa :
	 * <ul>
	 * <li>Overview of the returned payload : [ [Envelope Length] | [Envelope] | [Content] ]</li>
	 * </ul>
	 * <p>
	 * Where the envelope length respects the following :
	 * <ul>
	 * <li>2 bytes are reserved for envelope size (cf: {@link #ENVELOPE_LENGTH})</li>
	 * <li>If more space is needed, the 2 first bytes are set to zero 
	 * and 4 bytes (BIG_ENVELOPE_LENGTH - ENVELOPE_LENGTH) are added to contain the envelope length (cf: {@link #BIG_ENVELOPE_LENGTH})</li>
	 * </ul>
	 * 
	 * @see <a href=":">Fipa Representation</a>
	 * 
	 * @param encodedContent is the ACLMessageContent encoded in an array of bytes
	 * @param encodedEnvelope is the ACLMessageEnvelope encode in an array of bytes
	 * @return the payload
	 */
	private def buildEncodedACLMessage(encodedContent : byte[], encodedEnvelope : byte[]) : byte[] {
		val envelopeLength = encodedEnvelope.length
		val contentLength = encodedContent.length
		
		val envelopeSizeLength = if(envelopeLength < Short::MAX_VALUE) Constants::ENVELOPE_LENGTH else Constants::BIG_ENVELOPE_LENGTH
		
		val totalLength = envelopeLength + contentLength + envelopeSizeLength
		var completePayload = ByteBuffer::allocate(totalLength)
		
		if (envelopeSizeLength === Constants::ENVELOPE_LENGTH) {
			completePayload.putShort(envelopeLength as short)
		} else {
			completePayload.putShort(0 as short)
			completePayload.putInt(envelopeSizeLength)
		}

		completePayload.put(encodedEnvelope)
		completePayload.put(encodedContent)	
		
		return completePayload.array
	}

	/** 
	 * Gets the ACL Message from an ACL Transport Message.
		 * <ul>
	 * <li>The ACL Transport Message corresponds to the payload</p>
	 * <li>The payload has been previously encoded by {@link #encode(ACLMessage, Object...)} 
	 * as defined by FIPA : [ [Envelope Length] | [Envelope] | [Content] ]</li>
	 * </ul>
	 * <p>
	 * Workflow :
	 * <ol>
	 * <li>Get the envelope length</li>
	 * <li>Get back the envelope in an array bytes according to the previously recovered envelope length</li>
	 * <li>Get back the corresponding {@link ACLMessageEnvelope}</li>
	 * <li>Get the content length according to the global length and the envelope length</li>
	 * <li>Get back the content in an array of bytes according to the previously recovered content length</li>
	 * <li>Get back the corresponding {@link ACLMessageContent}</li>
	 * <li>Create a new ACL Message from the recovered envelope and content</li>
	 * </ol>
	 * 
	 * @param tMsg the ACLTransportMessage containing the encoded ACLMessage (payload)
	 * @param parameters
	 * @return the new ACLMessage decoded and rebuilt
	 */
	def decode(tMsg : ACLTransportMessage, parameters : Object*) : ACLMessage {
		decode(tMsg.payload, parameters)
	}

	/** 
	 * Gets the ACL Message from an ACL Transport Message.
	 * <ul>
	 * <li>The ACL Transport Message corresponds to the payload</p>
	 * <li>The payload has been previously encoded by {@link #encode(ACLMessage, Object...)} 
	 * as defined by FIPA : [ [Envelope Length] | [Envelope] | [Content] ]</li>
	 * </ul>
	 * <p>
	 * Workflow :
	 * <ol>
	 * <li>Get the envelope length</li>
	 * <li>Get back the envelope in an array bytes according to the previously recovered envelope length</li>
	 * <li>Get back the corresponding {@link ACLMessageEnvelope}</li>
	 * <li>Get the content length according to the global length and the envelope length</li>
	 * <li>Get back the content in an array of bytes according to the previously recovered content length</li>
	 * <li>Get back the corresponding {@link ACLMessageContent}</li>
	 * <li>Create a new ACL Message from the recovered envelope and content</li>
	 * </ol>
	 * 
	 * @param tMsg the ACLTransportMessage containing the encoded ACLMessage (payload)
	 * @param parameters
	 * @return the new ACLMessage decoded and rebuilt
	 */
	def decode(tMsg : byte[], parameters : Object*) : ACLMessage {
		this.envelopeEncodingService = new BitEfficientEnvelopeCodec
		
		var payloadBuffer = ByteBuffer::wrap(tMsg)
		
		// GET ENVELOPE :
		var envelopeLength = payloadBuffer.getShort(0) as int
		var envelopeSizeLength = Constants::ENVELOPE_LENGTH
		
		if (envelopeLength == 0) { // case of big envelope
			envelopeLength = payloadBuffer.getInt(Constants::ENVELOPE_LENGTH)
			envelopeSizeLength = Constants::BIG_ENVELOPE_LENGTH
		}

		var encodedEnvelope = Array.newInstance(typeof(byte), envelopeLength) as byte[]
		payloadBuffer.position(envelopeSizeLength)
		payloadBuffer.get(encodedEnvelope, 0, envelopeLength)
		var envelope = this.envelopeEncodingService.decode(encodedEnvelope)

		envelope.initContentEncodingService
		
		// GET CONTENT :
		var contentLength = payloadBuffer.^capacity - envelopeLength - envelopeSizeLength
		var encodedContent = Array.newInstance(typeof(byte), contentLength) as byte[]
		payloadBuffer.position(envelopeLength + envelopeSizeLength)
		payloadBuffer.get(encodedContent, 0, contentLength)
		var content = this.contentEncodingService.decode(encodedContent)
	
		return new ACLMessage(envelope, content)
    }

	/** 
	 * This method gets the encoding type of the payload (encoded ACLMessage)
     * 
     * @param envelope the ACLMessageEnvelope containing the encoding type we want
	 * @return encoding type of the payload
	 * @see PayloadEncoding
	 */
	@SuppressWarnings("unused_private_member")
	private def getPayloadEncoding(envelope : ACLMessageEnvelope) : PayloadEncoding {
    	try {
    		return PayloadEncoding.valueOf(envelope.getPayloadEncoding());
    	} catch (e : Exception) {
			warning(Messages::UNSPECIFIEDENCODING)
			return PayloadEncoding::UTF8
		} 	
    }

	/** 
	 * Instantiates the {@link #contentEncodingService} to use 
	 * to decode the encode/decode the content of a given ACL Message
	 * according to the ACL representation defined in the envelope.
	 * 
	 * @param envelope
	 * @see ACLRepresentation
	 */
	private def initContentEncodingService(envelope : ACLMessageEnvelope) {
    	var aclRepresentation = envelope.aclRepresentation
    	
    	if (aclRepresentation.equalsIgnoreCase(ACLRepresentation::BIT_EFFICIENT.value)) {
    		this.contentEncodingService = new BitEfficientACLCodec
		} 
    	else if (aclRepresentation.equalsIgnoreCase(ACLRepresentation::STRING.value)) {
    		this.contentEncodingService = new StringACLCodec
		} 
    	else if (aclRepresentation.equalsIgnoreCase(ACLRepresentation::XML.value)) {
    		this.contentEncodingService = new XMLACLCodec
    	}
    	else if (aclRepresentation.equalsIgnoreCase(ACLRepresentation::JSON.getValue())) {
    		this.contentEncodingService = new JSONACLCodec
		} else {
			throw new IllegalStateException
		}
    }

	/** 
	 * Instantiates the {@link #contentEncodingService} and the {@link #envelopeEncodingService} to use 
	 * to decode the encode/decode the content and the envelope of a given ACL Message
	 * according to the ACL representation defined in the envelope.
	 * 
	 * @param envelope
	 * @see ACLRepresentation
	 */
	private def initEncodingServices(envelope : ACLMessageEnvelope) {
    	var aclRepresentation = envelope.aclRepresentation
    	
    	if (aclRepresentation.equalsIgnoreCase(ACLRepresentation::BIT_EFFICIENT.value)) {
    		this.contentEncodingService = new BitEfficientACLCodec
			this.envelopeEncodingService = new BitEfficientEnvelopeCodec
		} 
    	else if (aclRepresentation.equalsIgnoreCase(ACLRepresentation::STRING.value)) {
    		this.contentEncodingService = new StringACLCodec
			this.envelopeEncodingService = new BitEfficientEnvelopeCodec
		} 
    	else if (aclRepresentation.equalsIgnoreCase(ACLRepresentation::XML.value)) {
    		this.contentEncodingService = new XMLACLCodec
    		this.envelopeEncodingService = new XMLEnvelopeCodec
    	}
    	else if (aclRepresentation.equalsIgnoreCase(ACLRepresentation::JSON.value)) {
    		this.contentEncodingService = new JSONACLCodec
    		this.envelopeEncodingService = new BitEfficientEnvelopeCodec
    	}
    	else {
			throw new IllegalStateException
		}
    }

	/** 
	 * Getter of contentEncodingService
	 * 
	 * @return the contentEncodingService used to encode the ACLMessageContent
	 */
	public def getContentEncodingService : ACLMessageContentEncodingService {
		this.contentEncodingService
	}

	/** 
	 * Setter of contentEncodingService used to encode the ACLMessageContent
	 * 
	 * @param contentEncodingService to be set
	 */
	public def setContentEncodingService(contentEncodingService : ACLMessageContentEncodingService) {
		this.contentEncodingService = contentEncodingService
	}

	/** 
	 * Getter of envelopeEncodingService
	 * 
	 * @return envelopeEncodingService used to encode the envelope
	 */
	public def getEnvelopeEncodingService : ACLMessageEnvelopeEncodingService {
		this.envelopeEncodingService
	}

	/** 
	 * Setter of envelopeEncodingService used to encode the envelope
	 * 
	 * @param envelopeEncodingService to be set
	 */
	public def setEnvelopeEncodingService(envelopeEncodingService : ACLMessageEnvelopeEncodingService) {
		this.envelopeEncodingService = envelopeEncodingService
	}

}
